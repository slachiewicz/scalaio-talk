<!DOCTYPE html>
<meta charset="utf-8">
<style>

.link {
  stroke: #333;
  stroke-width:0.1;
}

.node {
  stroke: #333;
}

</style>
<body>
<script src="http://d3js.org/d3.v3.min.js"></script>
<script src="http://d3js.org/colorbrewer.v1.min.js"></script>
<script>

var width = 1200,
    height = 640;

var svg = d3.select("body").append("svg")
    .attr("width", width)
    .attr("height", height);

var force = d3.layout.force()
    .size([width, height]);

d3.csv("./pg-vertices.csv", function(vertices) {
  var vById = {};
  vertices.forEach(function(v) {
    vById[v.id]=v;
  });
  d3.csv("./pg-edges.csv", function(edges) {
    edges.forEach(function(e){
      e.source = vById[e.source];
      e.target = vById[e.target];
    });

    // Run the force layout.
    force
        .nodes(vertices)
        .links(edges)
        .start();

    var nRuns = 50; /*ideally #verticesÂ² */
    for (var i = 0; i < nRuns; ++i) {
      console.log("running force: " + (100*i/nRuns) + "%");
      force.tick();
    }
    force.stop();

    // Create the link lines.
    var link = svg.selectAll(".link")
        .data(edges)
      .enter().append("line")
        .attr("class", "link")
        .attr("x1", function(d) { return d.source.x; })
        .attr("y1", function(d) { return d.source.y; })
        .attr("x2", function(d) { return d.target.x; })
        .attr("y2", function(d) { return d.target.y; });

    // Create the node circles.
    var rangePg = d3.extent(vertices, function(v) {return v.pg;});
    vertices.forEach(function(v) {
      v.pg_s = (v.pg-rangePg[0])/(rangePg[1]-rangePg[0]);
    });
    var node = svg.selectAll(".node")
        .data(vertices)
      .enter().append("circle")
        .attr("class", "node")
        .attr("cx", function(d) { return d.x; })
        .attr("cy", function(d) { return d.y; })
        .attr("fill", function(v) {
          var col = colorbrewer.RdYlBu[10][Math.floor(colorbrewer.RdYlBu[10].length * v.pg_s)];
          return col;
        })
        .attr("r", function(v) { return Math.abs(Math.floor(30 * v.pg_s)-15); });
        //.call(force.drag);

    window.tick = function () {
      link.attr("x1", function(d) { return d.source.x; })
          .attr("y1", function(d) { return d.source.y; })
          .attr("x2", function(d) { return d.target.x; })
          .attr("y2", function(d) { return d.target.y; });

      node.attr("cx", function(d) { return d.x; })
          .attr("cy", function(d) { return d.y; });
    }

    force.on("tick", tick);

    window.runForce = function() {
      force.start()
      force.tick();
      force.stop();
    }
  });
});

</script>
